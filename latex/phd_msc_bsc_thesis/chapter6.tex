% !TeX root=_main_.tex
% chapter6

\chapter{نتیجه‌گیری و کارهای آتی}\label{ch:6}
\thispagestyle{empty}

\epigraph{
	«ما ممکن است امیدوار باشیم که ماشین‌ها در نهایت در همه زمینه‌های هوشـمند با انسان رقابت کنند، اما بـهترین زمینه برای شروع کدام است؟!»
}
{$ \maltese $ {\large آلِن تورینگ}}



\section{نتیجه‌گیری}
دکتر انــدرو ان‌جی\LTRfootnote{Andrew Ng (\href{http://www.andrewng.org/}{http://www.andrewng.org/})}
 هوشِ مصنوعی را یک الکتریسیته جدید می‌نامد که می‌تواند تحول بزرگ بعدی را در صنعت رقم بزند. یادگیری ژرف و نگاه متفاوت آن به حل مسئـله تا همین الان این تحول بزرگ را در وظیفه‌هایی مانند پردازش تصویر، پرازش صوت، پردازش متن و ترجمه ماشینی رقم زده‌ است. سال 2017 آغاز استفاده از یادگیری ماشینی در آزمون فازی و تولید داده آزمون بود
 \cite{Godefroid:2012:SWF:2090147.2094081, DBLP:journals/corr/abs-1711-04596}.
 پژوهشگران مایکروسافت برای نخستین بار از این فنون در آزمون فازی استفاده کردند. در این پایان‌نامه ما از مدل‌های یادگیری ژرف برای یادگیری ساختار فایل‌های پیچیده و سپس تولید داده آزمون جدید به‌منظور استفاده در فرایند آزمون فازی استفاده کردیم. به‌‌طور خاص هر فایل را می‌توان نمونه‌ای مشتق شده از زبان یا گرامر ساختار آن دانست. براین اساس ما با استفاده از شبکه‌های عصبی مکرر اقدام به ایجاد یک مدل زبانی عصبی برای هر ساختار فایلی می‌کنیم که یک توزیع احتمالی از چگونگی وقوع نشانه‌ها در یک فایل را با آموزش روی یک مجموعه داده تخمین می‌زند. سپس این مدل زبانی را برای تولید فایل‌های جدید به‌کار می‌بندیم. یک ویژگی مفید امکان تشخیص و تمایز بین داده و فراداده در یک فایل با استفاده از چنین مدل‌هایی است در نتیجه می‌توان جابه‌جایی آزمون فازی را با استناد به تفکیک داده و فراداده به‌نحو هوشمندتری انجام داد. دو الگوریتم پیشنهادی در این راستا نشان دادند چنین روشی قادر به اجرای بخش‌های بیشتری از کد یک  \gls{SUT} است و پوشش کد بیشتری را رقم می‌زند که در نتیجه امکان شناسایی خطا نیز افزایش خواهد یافت.
 
 در فصل \ref{chapter1}، مسائلی را در باب سخت بودن تولید داده آزمون برای رسیدن به پوشش کد بالا در آزمون فازی قالب‌های فایل با ساختار پیچیده مثل \gls{PDF} مطرح کردیم و دیدیم که چنان‌چه بتوان با استفاده از گرامر ورودی داده‌های آزمون را تولید کرد، تعداد داده‌هایی که در مراحل اولیه توسط کدهای مدیریت استثنای تجزیه‌گر رد می‌شوند کاهش یافته و قادر به نفوذ به مسیرهای عمیق‌تر برنامه خواهیم بود. با این ایده و براساس مطالعات اولیه و کارهای قبلی که در فصل‌های \ref{chapter2} و \ref{related_work} به آنها اشاره کردیم، در فصل \ref{ch:4} یک روش یادگیری ساختار فایل را پیشنهاد دادیم که تولید داده آزمون مبتنی بر گرامر را خودکار می‌کند. در فصل \ref{ch:5} هم ابتدا پارامترهایی را که در تولید خودکار داده آزمون از روی مدل‌های یادگیری ژرف، نقش دارند شناسایی و سپس آزمایش‌هایی را برای بررسی و مقایسه تأثیر هریک از این پارامترهای طرح‌ریزی، پیاده‌سازی و اجرا نمودیم.
 
 یک نتیجه‌گیری مهم که آزمایش‌های ما نشان می‌دهند این است که افزایش ظرفیت محاسباتی و پیچیدگی شبکه‌های عصبی ژرف که در نتیجه قدرت حل مسئله یک شبکه را بالا می‌برد لزوماً منجر به نتایج بهتری در آزمون فازی نخواهد شد و مشاهده کردیم که مدل‌های ساده مدل‌های پیچیده‌تر را در پوشش کد \gls{SUT} شکست می‌دهند. این مدل‌ها طبیعتاً به‌زمان کمتری برای آموزش نیاز داشته و تولید داده با استفاده از آنها نیز سریع‌تر خواهد بود. بنابراین از همه نظر مقرون به صرفه هستند.
 
 روش پیشنهادی در این پایان‌نامه، در عین مزایایی که برای آن برشمرده شد محدودیت‌ها و نقاط ضعفی دارد. بزرگترین محدودیت را می‌توان عدم اطلاع مدل مولد از وضعیت \gls{SUT} دانست. به‌عبارت بهتر مدل مولد در غیاب \gls{SUT} و تنها روی مجموعه داده‌های یک قالب فایل آموزش دیده و سپس اقدام به تولید داده‌های آزمون می‌کند. فازر پیشنهادی نیز فاقد یک حلقه بازخورد برای دریافت اطلاعات زمان اجرای \gls{SUT} است. این در حالی است که همواره بازخوردهای اجرای \gls{SUT} می‌تواند حاوی اطلاعات خوبی برای پیش‌برد ادامه فرایند آزمون در اختیار فازر قرار دهد. این محدودیت می‌تواند به‌عنوان کار آتی مورد بررسی قرار گیرد. مشکل بعدی که البته مختص به روش پیشنهادی ما نبوده و هر روش یادگیری ماشینی در این زمینه با آن مواجه است نیاز به تعدادی زیادی فایل به‌عنوان مجموعه داده است. برای قالب‌های مشهور فایل مانند \gls{PDF} که مورد مطالعاتی این‌ پایان‌نامه بود، این مشکل پُررنگ نیست اما اگر برای یک قالب خاص امکان تهیه مجموعه داده بزرگی نباشد، استفاده از این روش تقریباً غیر ممکن خواهد بود. 

در هر حال تلاش در راستای موضوع این پایان‌نامه صرف نظر از نتایج تجربی آن به دلیل پیوند دو شاخه به‌ظاهر کمتر مرتبط در علم کامپیوتر یعنی یادگیری ژرف و آزمون فازی ارزشمند به‌نظر می‌رسد. به‌ویژه که طراحی و آموزش شبکه‌های عصبی ژرف کاری مهیّج بوده و این مسیر پژوهشی نیز در ابتدای راه خود است. در این بین دو حوزه مذکور که این پایان‌نامه بر آنها بیان شده، نیز هرکدام در حالت کلی دارای مزایا و معایبی هستند که ممکن است برخی از آنها را قبلاً هم ذکر کرده باشیم، با این حال در پایان این بخش نگاهی کوتاه به مزایا، معایب و آینده هریک از این دو حوزه خواهیم داشت؛ زیرا می‌توانند در تعیین روند پژوهش‌های آتی مؤثر واقع شوند.



\subsection{مزایا و معایب یادگیری ژرف}
یادگیری ژرف و به تبع آن شبکه‌های عصبی ژرف در انجام وظایف ساده‌ برای انسان، سخت برای ماشین بسیار موفق ظاهر شده‌اند. با توجه به افزایش قدرت محاسبات انجام حجم وسیعی از محاسبات در مسائل پیچیده، ارزان‌تر از نوشتن یک الگوریتم خاص می‌باشد به‌نحوی که در آینده شاهد افزایش ظرفیت‌های سخت‌افزاری برای توسه چنین مدل‌هایی در مقیاس‌های بسیار بزرگ خواهیم بود. دو ویژگی بسیار مهم این شبکه‌ها عبارتند از \gls{Generalization}ی و \gls{Adaptive}ی  \cite{Goodfellow-et-al-2016}. تعمیم‌پذیری بدین معنی است که در صورت آموزش صحیح، شبکه برای ورودی‌های جدید نیز درست کار خواهد کرد. تطبیق‌پذیری یعنی در صورتی که داده‌ها تغییر کند، شبکه هم توانایی تغییر خواهد داشت. یعنی یک مدل می‌تواند برای حل خانواده‌ای از مسائل مشابه طراحی و ساخته شود و هر بار با داده‌های مختلفی آموزش ببیند.

شبکه‌های عصبی سراسر فایده و نوش‌دارویِ حوزه محاسبات جدید نیستند و در عین حال معایبی دارند. از جمله اینکه آموزش آنها سخت و بسیار مستعد خطا است. در واقع دقت نتایج بستگی زیادی به مجموعه آموزش دارد؛ به نحوی که یک مجموعه آموزش ضعیف (کوچک یا نادرست) عملاً شبکه غیرقابل استفاده‌ای را نتیجه می‌دهد. دیگر آنکه قوانین مشخصی برای طراحی یک شبکه جهت کاربردی خاص وجود ندارد. به عبارت بهتر تعیین ابرپارامترها مسئله تصمیم‌ناپذیر است؛ یعنی یک نمی‌توان به صورت الگوریتمی بهترین مجموعه ابرپارامتر را برای یک شبکه در یک وظیفه خاص تعیین کرد. این کار معمولاً با سعی و خطا انجام می‌شود و بلأخره اینکه نمی‌توان به فیزیک یا قانون حاکم بر مسئله حل‌شده توسط شبکه پی برد و تنها با مشتی اعداد سروکار خواهیم داشت که روی یک مجموعه یک هدف خواسته شده را بهینه کرده‌اند. 


\subsection{مزایا و معایب آزمون فازی}
آزمون فازی چندین سودمندی دارد. در درجه نخست سادگی و راحتی خودکارسازی فرایند شرح داده شده است. به همین دلیل، فازرهای بسیاری توسعه داده شده است. برای استفاده از فازرهای موجود تنها انتخاب \gls{SUT} و فراهم ساختن تعدادی داده آزمون اولیه یا قالب ورودی لازم است. فازر می‌تواند به‌صورت یک \gls{BackgroundProcess} و بدون دخالت اضافی کاربر، در یک حلقه بی‌نهایت، به مدت طولانی اجرا شود. برای ساخت یک فازر جدید نیز کافی است پیمانه‌های ‏شکل \ref{ch2_fuzz_testing_flowchart_crop.pdf}، توسعه داده شده و در کنار هم قرار گیرند. 

آزمون فازی همچنین کاستی‌های آزمون معمولی که به‌صورت دستی صورت می‌پذیرد را جبران می‌کند. آزمون‌های نوشته شده به صورت دستی تا حدودی تمایل به پیش‌دانسته‌های ذهنی فرد آزمون‌گر در مورد کد دارند. آزمون فازی از انحراف یاد شده مستثنی است و می‌تواند ورودی‌های بدشکل را به نحوی تولید کند که پیش از آن هیچگاه، به ذهن فرد یا افراد آزمون‌گر نرسیده است. با گذشت سه دهه از ابداع آزمون فازی این روش جایگاه ویژه‌ای در صنعت و نیز در پژوهش یافته است و به همین دلیل کار بر روی آن ارزشمند و اثر بخش است.

در حالی که آزمون فازی در پیدا کردن خطاهای فساد حافظه، بسیار خوب عمل می‌کند، خطاهای پیچیده‌تر مانند خطاهای منطقی به ندرت توسط این آزمون قابل شناسایی هستند؛ چرا که آشکارسازی آنها نیازمند به اتمام رسیدن اجرای برنامه بدون خطای حافظه و داشتن \gls{Oracle} آزمون است. افزون بر این تحریک برخی خطاهای حافظه برای فازرها بسیار سخت خواهد بود. مسئله انفجار مسیر که ناشی از وجود حلقه‌های تکرار و شرط‌های تودرتو است مانع از اجرای نمادین برنامه‌های پیچیده می‌شود. در نتیجه به‌کارگیری اجرای نمادین در آزمون فازی جعبه سفید در بسیاری موارد ممکن نیست و این مسئله به پوشش کد پایین و خوب آزمون نشدن برنامه می‌انجامد.

آزمون فازی ممکن است برای اهداف سوء مورد استفاده قرار گیرد. یعنی شناسایی آسیب‌پذیری‌ها توسط فرد مهاجم و بهره‌برداری از آنها جهت حمله به یک سیستم نرم‌افزاری. در نتیجه روش‌هایی برای مقابله با امکان آزمون‌پذیری یک نرم‌افزار مطرح شده‌اند که می‌توان آنها را در طبقه روش‌های ضد مهندسی معکوس دانست. از جمله این روش‌ها می‌توان به حوزه‌ای جدید که اخیراً  تحت عنوان 
{\gls{AntiFuzzing}
مطرح شده است، اشاره کرد که در آن اقداماتی برای کندسازی یا به‌کلی مانع شدن کشف خطاها توسط آزمون فازی انجام می‌گیرد. کاهش کارآمدی و پوشش خطاها دو رویکرد از میان رویکردهای موجود در این زمینه هستند. دیگر فنون مقابله با مهندسی معکوس نظیر مبهم‌سازی کد را نیز می‌توان در ضد فازینگ به‌کار گرفت. 
چنان‌چه این رویکردها به بلوغ خوبی برسند و توسعه‌دهندگان آنها را در برنامه‌های خود لحاظ نمایند، در آینده بایستی به دنبال فنون جایگزین برای روش‌ آزمون فازی جعبه خاکستری و به‌طور کلی آزمون‌ فازی باشیم. البته استفاده از این فن آزمون در بین توسعه دهندگان و پیش از انتشار نسخه نهایی نرم‌افزار همچنان در صنعت ادامه خواهد یافت.




\section{نوآوری‌ها}
مجموعه نــوآوری‌ها، دستاوردها و محصولات کار پژوهشی ما در قالب این پایان‌نامه عبارت است از:
\begin{enumerate}
	\item{
		خودکارسازی فرایند یادگیری ساختار فایل ورودی و تولید داده‌های آزمون برای آزمون فازی قالب فایل با به‌کارگیری روش‌های جدید یادگیری ژرف. 
	}
	
	\item{
		بهبود پوشش کد \gls{SUT} با به‌کار بست روشی ترکیبی یعنی تولید فراداده و داده‌های متنی، مبتنی بر گرامر و سپس تزریق داده‌های دودویی مبتنی بر جابه‌جایی تصادفی در مکان‌های تعیین شده.
	}
	\item{
		شناسایی و استخراج پارامترهای مؤثر در تولید داده آزمون به‌روش یادگیری ژرف و ارزیابی تأثیر آنها با ارایه مجموعه‌ای از آزمایش‌های کنترل شده.
		
	}
	\item{
		معرفی یک مجموعه دانه اولیه و یک مجموعه داده آزمون برای آزمون فازی  قالب فایل \gls{PDF} تحت یک پیکره از فایل‌های \gls{PDF} به‌همراه پوشش کد‌های آنها.
		
	}
	
	\item{
		طراحی و پیاده‌سازی یک فازر قالب فایل ساده با معماری کاملاً پیمانه‌ای و قابل حمل، مجهز به پیمانه تولید خودکار داده‌های آزمون با استفاده از مدل‌های مولد.	
	}
	
\end{enumerate}
به‌طور خلاصه در این پایان‌نامه یک مجموعه داده، چهار مدل مولد، دو الگوریتم فاز و یک فازر قالب فایل پیشنهاد و معرفی گردید که همه آنها در قالب یک بسته نرم‌افزاری تحت عنوان \lr{IUST Deep Fuzz} منتشر شده‌اند. از این محصول می‌توان در عمل برای آزمون فازی و شناسایی خطاهای نرم‌افزارهایی با ورودی فایل استفاده کرد. تنظیمات کنونی بر روی قالب فایل \lr{PDF} تعیین شده است اما به‌راحتی قابل تغییر است. نرم‌افزارهای با ورودی فایل علاوه‌بر \gls{PDF}خوان‌ها، شامل خانواده وسیع کامپایلرها، مرورگرهای وب، محیط‌های توسعه مجتمع و غیره می‌شوند، که همه آنها در طبقه برنامه‌های کاربردی و بسیار مهم قرار می‌گیرند. تقریباً در همه موارد مذکـور، داده کافی برای ایجاد مدل مولد وجود دارد. به‌عنوان مثال در آزمون مرورگرها، ایجاد یک مدل مولد برای تولید فایل‌های ترکیبی \lr{HTML}، \lr{CSS} و \lr{JavaScript} داده آزمون بهتری نسبت به تولید تنها یکی از این فایل‌ها 
\cite{yaghoubi1392}
فراهم می‌کند و از طرفی برای هر سه قالب فایل نام‌برده مجموعه داده به فراوانی یافت می‌شود.




\section{ملاحظات اعتبارسنجی}
در این پایان‌نامه بر بهبود معیار پوشش کد در آزمون فازی، به‌طور مکرر تأکید ورزیدیم. منظور از پوشش کد در اینجا پوشش دستور (یا در حالت کلی‌تر پوشش بلوک پایه است). در مواردی به پوشش مسیر نیز اشاره کردیم و به‌عنوان مثال در مورد پوشش مسیرهای اجرایی عمیق برنامه صحبت به میان آوردیم. ذکر این نکته ضروری است که معیارهای پوشش دستور و پوشش مسیر متفاوت هستند و همچنان‌که در فصل 
\ref{chapter2}
 دیدیم، پوشش مسیر معیار سخت‌گیرانه‌تری نسبت به پوشش دستور است؛ یعنی ممکن است تمامی دستورات برنامه در یک یا چند اجرا، حداقل یک‌بار اجرا شوند ولی لزوماً تمامی مسیرهای اجرایی پوشش داده نشوند. 

یک برنامه با یک دستور 
\lr{\textit{if}}
ساده را در نظر بگیرید. اگر برنامه در حالتی اجرا شود که حاصل ارزیابی عبارت شرطی درست شود، همه دستورات (همچنین همه بلوک‌های پایه) برنامه اجرا می‌شوند. در این حالت پوشش بلوک پایه معادل 100 درصد خواهد بود. در حالی که این برنامه در بَدَوی‌ترین شکل خود، دو مسیر اجرایی دارد: یک مسیر که از بدنه دستور شرطی 
\lr{\textit{if}}
عبور می‌کند و مسیر دیگر که وارد بدنه دستور 
\lr{\textit{if}}
نمی‌شود. برای سناریوی اجرای ذکر شده، پوشش مسیر 50 درصد است. بنابراین تفاوت معناداری میان پوشش دستور و پوشش مسیر در این مثال وجود دارد. ممکن است خواننده با این ابهام روبه‌رو شود که در چنین حالتی، نتایج گزارش شده موردی بوده و قابل تعمیم نیست.

چنان‌چه یک دستور (بلوک پایه) جدید اجرا شود، می‌توان گفت یک مسیر جدید اجرا شده است. بنابراین از این منظر، تلاش برای افزایش پوشش بلوک پایه منجر به افزایش پوشش مسیر نیز می‌گردد. اما دو مجموعه برابر از پوشش‌های دستور، لزوماً پوشش مسیر برابری به ‌دست نمی‌دهند. اندازه‌گیری پوشش مسیر دشوار‌تر بوده و سربار بیشتری به آزمون تحمیل می‌کند. از لحاظ تئوری نیز، برخی از مسیرهای ایستای برنامه، غیر قابل دسترسی هستند و با وجود حلقه‌های تکرار در برنامه، تعداد مسیرهای اجرایی در مواردی بی‌نهایت می‌شود. به سبب این‌گونه مسائل، ابزارهای معرفی شده در فصل \ref{chapter2}، هیچ‌کدام پوشش مسیر اجرایی را اندازه‌گیری نمی‌کنند. در بیشتر کارهای مربوط به آزمون فازی منظور از پوشش کد، همان پوشش در سطح دستورات برنامه است. بنابراین آمار و ارقام ارایه شده در این پایان‌نامه نیز مشابه کارهای پیشین برحسب همان میزان پوشش دستورات و در حالت کلی‌تر پوشش بلوک پایه بنا شده است. 

در آزمایش‌هایی که پوشش دستور دو مجموعه داده آزمون، دقیقاً برابر باشد، برای مقایسه لازم است تا پوشش مسیر اندازه‌گیری گردد. در آزمایش‌های انجام شده توسط ما، همواره پوشش بلوک پایه مجموعه‌های آزمون استفاده شده پس از گرفتن اجتماع، متفاوت بوده است که نشان از متفاوت بودن پوشش مسیر‌ها نیز دارد. لذا نتایج گزارش شده، صحت داشته و دلالت بر بهبود میزان پوشش کد 
\gls{SUT}
در حالت کلی دارد. در هر صورت، ما در نظر داریم تا آزمایش‌های خود را در مقیاس بسیار بزرگ‌تری و روی قالب‌های فایل مختلف، تکرار کرده و اندازه‌گیری درست پوشش مسیر را نیز برای آزمایش‌های جدید انجام دهیم.   


\section{کارهای آتی}
پایان‌نامه پیش‌ِرو، مباحث تولید داده آزمون، آزمون فازی و یادگیری ژرف ( و به طور خاص‌تر مدل‌های زبانی عصبی) را به یکدیگر پـیوند زده است. هر سه موضوع یاد شده از موضوعات مهم، کاربردی و داغ در پژوهش‌های علوم و مهندسی کامپیوتر هستند. پیشنهادهای زیادی برای کارهای آتی مرتبط با موضوع این پایان‌نامه مطرح است که در ذیل به چندین مورد از آنها اشاره می‌کنیم.

\begin{enumerate}
	\item{
		\textbf{استفاده از دیگر مدل‌ها و معماری‌های شبکه‌های عصبی ژرف در تولید داده آزمون. }
		به‌عنوان مثال می‌توان از مدل‌های
		 \gls{GenerativeAdversarialNetwork} \cite{NIPS2014_5423}
		  برای تولید داده آزمون استفاده کرد. به‌طور خلاصه
		 \gls{GenerativeAdversarialNetwork}
		  از دو شبکه عصبی تشکیل شده است. یک شبکه مولد که داده‌های جدید را تولید می‌کند و یک شبکه که آنها ارزیابی می‌کند. هدف شبکه مولد این است که داده‌هایی تولید که از دید شبکه ارزیاب خطای کمتری داشته باشند. از \gls{GenerativeAdversarialNetwork} در تولید محیط‌های جدید در بازی‌های رایانه‌ای استفاده شده‌ است اما کاربرد آنها محدود به‌این مورد نیست. 
	
	 
	}

\item{
	\textbf{استفاده از یادگیری ژرف در دیگر فازرها.}
	به‌عنوان نمونه یادگیری ساختار پروتکل‌های شبکه که می‌تواند برای تولید داده در فازرهای شبکه و پروتکل‌ها استفاده شود؛ این مسئله به‌ویژه در آزمون پروتکل‌هایی با ساختار ناشناخته مثل بات‌نت‌ها قابل توجه است. در این مورد یادگیری ممکن است به اهداف مهندسی معکوس کمک نماید.
	
}

\item{
	\textbf{تولید داده آزمون براساس اهداف مختلف.}
هدف آزمون فازی و فازر نبایست لزوماً افزایش پوشش کد یا به‌عبارتی
 \lr{Input Gain}
  تعیین شود. داده‌های آزمونی که توابع ناامن را فراخوانی می‌کنند برای مثال حائز اهمیت هستند 
  \cite{amini1395}.
  ایجاد مدل‌های یادگیری که امتیاز را به فراخوانی مجموعه‌ای از توابع ناامن نسبت دهند، به‌این امید که آزمون برنامه با ورودی‌هایی که این مسیرها را اجرا می‌کند، منجربه‌ وقوع خطای حافظه می‌شود، می‌تواند جالب و قابل توجه باشد.  
}

\item{
\textbf{افزودن حلقه بازخورد به فازر پیشنهادی  در این پایان‌نامه.}
قبلاً نیز اشاره شد که یک محدودیت روش پیشنهادی عدم استفاده از حقله بازخورد است. می‌توان این حلقه را در قالب یک فازر جدید اضافه کرد یا برای مثال از روش پیشنهادی برای تولید دانه‌های اولیه برای فازرهایی مثل \lr{AFL} استفاده کرد که در این صورت بایستی یک مرحله \gls{SeedMinimization} نیز برای افزایش کارایی \lr{AFL} ارایه شود.

}

\item{
	\textbf{افزودن تعامل کاربر به آزمون فازی جعبه سیاه.}
	تعامل کاربر با برنامه منجربه اجرای کدهای مربوط ‌به کارهای کاربر می‌شود. ما در برخی آزمایش‌های خود مشاهده کردیم که این امر تأثیر زیادی بر میزان پوشش کد دارد. البته این مورد با آزمون فازی واسط کاربر متفاوت است؛ زیرا، لزوماً همه تعامل‌ها مربوط به واسط کاربر نیستند و بعضی از آنها کدهای مربوط به مرحله پرداخت فایل را اجرا می‌کنند. تعامل کاربر نیازمند دخالت مستقیم کاربر  و انجام عملیاتی از طریق صفحه‌کلید یا دیگر ابزارهای ورودی است که در نتیجه خودکار نیست. بنابراین می‌توان فازری طراحی کرد که برروی یک داده آزمون ورودی تولید شده یک دنباله از عملیات کاربر را به‌طور خودکار و به‌صورت ترتیبی یا تصادفی انجام دهد. ما این مورد را در کار بعدی خود لحاظ می‌کنیم. 
	
}

\item{
	\textbf{استفاده از یادگیری ژرف در دیگر مراحل آزمون نرم‌افزار.}
	آزمون نرم‌افزار تنها مختص به مرحله تولید داده آزمون و مکان‌یابی خطا نیست. می‌توان در دیگر مراحل نیز از فنون یادگیری ژرف استفاده کرد. یک زمینه پژوهشی نو، ترمیم خودکار برنامه‌ها پس از مشخص شدن مکان خطا است. برای این منظور استفاده از مدل \gls{CAN} 
	\cite{DBLP:journals/corr/ElgammalLEM17}
	ایده جالبی به‌نظر می‌رسد. \gls{CAN}
	نوع خاصی از \gls{GenerativeAdversarialNetwork} است که تلاش می‌کند عوامل خلاقیت و تولید داده جدید را به آن اضافه کند. در ترمیم خودکار برنامه نیز نیازمند سازوکاری برای تنوع‌بخشی به قسمت‌های خطادار باهدف ترمیم آن قسمت‌ها، هستیم.
	
}

\end{enumerate}

\vspace{2.0cm}

\begin{center}
	{\LARGE $$\blacksquare\blacksquare\blacksquare$$}
\end{center}

 





