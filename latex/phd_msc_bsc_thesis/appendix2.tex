% !TeX root=_main_.tex

\chapter{فازر \lr{IUST-DeepFuzz} }\label{appendix:2}
\thispagestyle{empty}

در این پیوست جزئیات پیاده‌سازی و استفاده از روش پیشنهادی خود را در قالب محصول نرم‌افزاری \lr{IUST-DeepFuzz} شرح می‌دهیم. کلیه کد‌ها و مستندات این محصول از طریق صفحه پروژه در وب‌سایت  
\lr{\href{https://github.com/m-zakeri/iust\_deep\_fuzz}{GitHub}}\LTRfootnote{\href{https://github.com/m-zakeri/iust\_deep\_fuzz}{https://github.com/m-zakeri/iust\_deep\_fuzz}}
قابل مشاهده و دریافت است. برنامه به‌صورت مجموعه‌ای از اسکریپت‌های زبان پایتون نوشته شده است؛ لذا، روی هر سیستم عاملی پس از نصب کتابخانه‌ها و چارچوب‌های لازم قابل اجرا خواهد بود. فایل ‌های پروژه، به‌تفکیک وظایف، در تعدادی دایرکتوری سازمان‌دهی شده است.   
همچنین بخشی از فازر که عملیات آزمون فازی، پایش خطا و ابزارگذاری کد \gls{SUT} را انجام می‌دهد، به‌صورت یک فایل \lr{Batch} در سیستم عامل ویندوز نوشته شده است که در صورت تغییر سیستم عامل یا هریک از ابزار‌های پایش و ابزارگذاری \gls{SUT}، بایستی تغییر داده شود. پیمانه تولیدکننده خودکار داده‌های آزمون اما نیاز به تغییر ندارد.


\section{پیش‌نیازهای نرم‌افزاری و سخت‌افزاری}
پیش‌نیاز‌های نرم‌افزاری پروژه در جدول \ref{tabel:prerequests} آمده است. پس از نصب تمامی بسته‌ها اسکریپت‌های اصلی پروژه قابل اجرا خواهد بود. برای تسریع آموزش مدل‌ها استفاده از سیستمی با پردازش‌گر گرافیکی قوی (تعداد‌ هسته‌های بالا) توصیه می‌شود ولی الزامی نیست. همچنین پرادزش‌گر مرکزی قوی و حافظه اصلی بالا (8 گیگابایت و بیشتر) برای اجرای قابل قبول پروژه مورد نیاز خواهد بود.

\begin{table}[ht]
	\caption
	{
		بسته‌‌های نرم‌افزاری مورد نیاز جهت اجرای صحیح برنامه \lr{IUST DeepFuzz}.
	}
	\label{tabel:prerequests}
	\centering
	\onehalfspacing
	\begin{tabularx}{0.55\linewidth}{r r r}
		\toprule[1.5pt] 
		ردیف &
		بسته‌ نرم‌افزاری &
		نسخه مورد نیاز
		\\
		\midrule[1.5pt] 
		1 &
		\lr{Python} &
		نسخه $3.5$ و بالاتر
		\\
		%\hline 
		2 &
		\lr{TensorFlow} &
		نسخه $1.5$ و بالاتر
		\\
		%\hline 
		3 &
		\lr{Keras} &
		نسخه $2.2.0$
		\\
		\bottomrule[1.5pt]
		
	\end{tabularx} 
\end{table} 


\section{ساختار سطح بالای پروژه}
در دایرکتوری ریشه پروژه تعدادی فایل و تعدادی زیردایرکتوری قرار دارند که بخش‌های مختلف برنامه را تشکیل می‌دهند. در انتهای نام هر فایل یک عدد ترتیبی قرار دارد که نسخه‌ آن را مشخص می‌کند. در میان فایل‌های دارای یک نام بدین ترتیب فایل با نسخه بالاتر اجرایی است و نیازی به فایل‌های قبلی نیست. دایرکتوری‌ها عبارتند از:
  
\begin{itemize}

%% 1	
\item{
\textbf{دایرکتوری ریشه.}
در این دایرکتوری ریشه فایل‌های اصلی \gls{Configuration}، فایل تعریف مدل‌های ژرف، فایل آموزش مدل و تولید داده از مدل و نیز فایل راهنما وجود دارد. 
}

%% 2
\item{
	\textbf{دایرکتوری \lr{batch\_jobs}.}
	این دایرکتوری کدهای مربوط به پیمانه‌های تزریق و پایش (خطا و پوشش کد) فازر را شامل می‌شود.
}


%% 3
\item{
	\textbf{دایرکتوری \lr{binary\_to\_base64}.}
	این دایرکتوری برای کارهای آتی رزرو شده و در نسخه فعلی محصول به‌کار نمی‌رود.
}

%% 4
\item{
	\textbf{دایرکتوری \lr{dataset}.}
	این دایرکتوری همان‌طور که از نام آن پیداست. محل قرار گیری مجموعه داده مورد آموزش  و آزمون مدل‌ها است. برای قالب‌های فایل جدید کافی است مجموعه داده را زیردایرکتوری مختص به آن قرار دهیم. درحال حاضر مجموعه داده خوبی برای فایل‌های \gls{PDF} و مجموعه داده کوچکی نیز برای فایل‌های \lr{XML} داخل آن قرار دارند.
}

%% 5
\item{
	\textbf{دایرکتوری \lr{generated\_results}.}
	در این دایرکتوری داده‌های آزمون جدید تولید شده توسطه مدل‌های ژرف ذخیره می‌شوند.
}

%% 6
\item{
	\textbf{دایرکتوری \lr{ 	incremental\_update}.}
	این دایرکتوری شامل کدهای مربوط به بروزرسانی افزایشی و ساخت فایل‌های \gls{PDF} جدید است. بنابراین مختص آزمون فازی قالب فایل \gls{PDF} است و در قالب‌های فایل دیگر کاربردی ندارد. 
}

%% 7
\item{
	\textbf{دایرکتوری \lr{logs\_csv}.}
	در این دایرکتوری فایل‌های گزارش ضبط شده در فرایند آموزش مدل‌ها ذخیره می‌شود. این فایل‌ها شامل میزان خطا، دقت و سرگشتگی مدل در هر دوره اموزش هستند.
}

%% 8
\item{
	\textbf{دایرکتوری \lr{logs\_tensorboard}.}
	فایل‌های گزارش مربوط به ابزار مصورسازی \lr{Tensorboard} در این دایرکتوری ذخیره می‌شود. این فایل‌ها سپس توسط همین ابزار خوانده و گزارش‌های دقت، خطا، معماری مدل و غیره را به‌صورت تصویری در اختیار آزمون‌گر قرار می‌دهد.
}

%% 9
\item{
	\textbf{دایرکتوری \lr{ 	model\_checkpoint}.}
	در پایان هر دوره آموزش مدل، یک نمونه از مدل در این دایکتوری ذخیره می‌شود. هر نمونه مستقل از سایر نمونه‌های بوده است. آزمون‌گر بدین ترتیب پس از اتمام فرایند آموزش می‌تواند بهترین مدل را برای تولید داده آزمون انتخاب کند.
}

%% 10
\item{
	\textbf{دایرکتوری \lr{modelpic}.}
	این دایرکتوری شامل گراف محاسباتی مربوط به مدل‌های ژرف است که توسط کتابخانه \lr{Keras} تولید شده است. 
}

%% 11
\item{
	\textbf{دایرکتوری \lr{seed}.}
	این دایرکتوری پوشش کد تمامی فایل‌های دانه اولیه آزمون را ذخیره می‌کند.
}

\end{itemize}


\section{پیکربندی پروژه}
در حال حاضر این محصول مبتنی بر \gls{GUI} نیست و کلیه تنظیمات از طریق فایل \lr{config.py} در دایرکتوری ریشه مشخص می‌شود و مهمترین فایلی است که در پروژه در اختیار آزمون‌گر قرار دارد.
این فایل شامل تعدادی فرهنگ لغت است. هر فرهنگ لغت تعدادی فیلد به‌صورت کلید-مقدار دارد که کلید نام تنظیم ورودی بود که توسط برنامه مشخص شده است و مقدار آن توسط آزمون‌گر قبل از انجام آزمون تعیین می‌شود. فایل 
\lr{config.py}
کاملاً مستندگذاری شده و مقادیر قابل استفاده برای هر کلید در مقابل آن درج شده است. برای تغییر آن کافی است یکی از مقادیر معتبر را به‌جای مقدار پیش‌فرض قرار دهید. مهمترین تنظیم‌های قابل اعمال در این فایل عبارتند از:


\begin{itemize}

%% 1
\item{
	\textbf{\lr{file\_fromat}.}
این کلید قالب فایل مورد آزمون را مشخص می‌کند. برای مثال \gls{PDF} یا \lr{XML}.

}

%% 2
\item{
	\textbf{\lr{training\_set\_path}.}
این کلید آدرس مجموعه آموزش را مشخص می‌کند.

}

%% 3
\item{
	\textbf{\lr{validation\_set\_path}.}
این کلید آدرس مجموعه ارزیابی را مشخص می‌کند.

}

%% 4
\item{
	\textbf{\lr{testing\_set\_path}.}
این کلید آدرس مجموعه آزمون را مشخص می‌کند.

}

%% 5
\item{
	\textbf{\lr{new\_objects\_pathh}.}
	این کلید آدرس محل ذخیره داده‌های آزمون تولید شده را مشخص می‌کند.
	
}

\end{itemize}

افزون بر تنظیمات بالا، تعدادی از تنظیمات مختص آزمون فازی قالب \gls{PDF} هستند. این تنظیمات در فرهنگ لغت 
\lr{iu\_config}
تعریف شده‌اند؛ از جمله:
 

\begin{itemize}
%%% Just PDF
%% 01
\item{
\textbf{\lr{single\_object\_update}.}
این کلید مقادیر \lr{True} و \lr{False} را می‌‌گیرد و همان‌طور که از نام آن پیداست تعیین می‌کند که هنگام تولید فایل \gls{PDF} جدید تنها یک شیء بروزرسانی شود و یا چند شیء.
 

}


%% 02
\item{
	\textbf{\lr{portion\_of\_rewrite\_objects}.}
	این کلید نسبت تعداد اشیای مورد بروزرسانی را در حالت \lr{MOU} مشخص می‌کند. بنابراین تنها وقتی که تنظیم \lr{single\_object\_update} برابر \lr{False} است به‌کار می‌رود.   
	
}


%% 03
\item{
	\textbf{\lr{update\_policy}.}
	این کلید نوع انتخاب اشیاء برای بروزرسانی را مشخص می‌کند که می‌تواند یکی از موارد 
	\lr{random}
	برای انتخاب تصادفی، 
	\lr{bottom\_up}
	برای انتخاب برحسب شماره نزولی اشیاء و   
	\lr{top\_down}
	برای انتخاب برحسب شماره صعودی اشیاء باشد.
}


%% 04
\item{
	\textbf{\lr{raw\_host\_directory}.}
	این کلید آدرس فایل‌های میزبان را مشخص می‌کند. 
}

\end{itemize}



\section{پیاده‌سازی‌ها}
هر یک از اسکریپت‌های پایتون بخشی از پروژه را پیاده‌سازی می‌کند. فایل 
\lr{deep\_models.py}
هریک از مدل‌های ژرف را در قالب یک تابع پایتون تعریف کرده است. فایل 
\lr{lstm\_text\_generation\_pdf\_objs\_9datafuzz.py}
الگوریتم فاز عصبی داده و فایل 
\lr{lstm\_text\_generation\_pdf\_objs\_9formatfuzz.py}
الگوریتم فاز عصبی فراداده را پیاده‌سازی کرده است. همچنن فایل 
\lr{iu\_6.py}
بروزرسانی افزایشی \gls{PDF} را پیاده‌سازی می‌کند.


\subsection{تعریف مدل‌ها}
در 
\lr{Keras}
به دو صورت می‌توان مدل‌های یادگیری را تعریف کرد. یک روش با استفاده از پشته‌کردن لایه‌ها مختلف که برای مدل‌های ترتیبی به‌کار می‌رود و یک روش با استفاده از کلاس \lr{Model} و \lr{API}های آن، که برای ساخت مدل‌هایی با چندین ورودی‌ و خروجی و به‌طور کلی معماری‌های پیچیده‌تر استفاده می‌شود. تعریف مدل‌های ما با روش اول انجام شده است. در برنامه \ref{code:deepmodels2} تعریف مدل‌ها را آورده‌ایم.

\begin{LTR}
\singlespacing
	\lstinputlisting[language=Python, caption={پیاده‌سازی مدل‌های یادگیری در Keras}, label={code:deepmodels2}]{deepmodels2.py}
\doublespacing
\end{LTR}



\subsection{آموزش و تولید داده}
کدهای مربوط به فرایند آموزش مدل و تولید داده از مدل در یک فایل قرار دارند به ترتیب اجرا می‌شوند. در اینجا از ذکر کدها امتناع می‌کنیم؛ زیرا طولانی بوده و فایل کامل در مخزن پروژه وجود دارد. اجرای نهایی برنامه پس از انجام تنظیمات گفته شده از طریق فراخوانی هر فایل در خط‌فرمان سیستم عامل در مسیر پروژه انجام می‌شود. برای آموزش مدل می‌توان تعداد دوره محدودی درنظر گرفت و سپس با بررسی میزان خطا آموزش را متوقف ساخت. 


\subsection{پیاده‌سازی آزمون فازی}
آزمون فازی همان‌طور که گفتیم توسط یه برنامه \lr{Batch} روی سیستم عامل ویندوز نوشته شده است. برنامه \ref{code:deepfuzz.bat} یک پیاده‌سازی اولیه از  آن را نشان می‌دهد.
\singlespacing
\begin{LTR}
	\lstinputlisting[language=command.com, caption={پیاده‌سازی آزمون فازی}, label={code:deepfuzz.bat}]{deepfuzz.bat}
\end{LTR}
\doublespacing


\section{ملاحظات عملی}
در پیاده‌سازی همواره با برخی از پیچید‌گی‌ها روبه‌رو می‌شویم که در تئوری مسئله وجود ندارد. در این پروژه تبدیل تمامی توالی‌های آموزشی به بردار‌های عددی نیازمند حافظه‌‌ بالای 20 گیگابایت بود. به عبارت دیگر امکان بارگذاری یک‌باره همه مجموعه آموزش در حافظه اصلی نبود.
برای حل این مشکل، هر بار یک دسته از توالی‌ها را انتخاب، آنها را از حافظه‌ جانبی وارد حافظه‌ اصلی کرده و پس از شرکت دادن در فرایند آموزش، این دسته را خارج و دسته بعدی را می‌خوانیم. این امکان با نوشتن از یک تابع از نوع \lr{Generator}  به کد برنامه اضافه گردید. مصرف حافظه به‌این ترتیب با تعیین اندازه دسته، در اختیار برنامه‌نویس و آزمون‌گر خواهد بود.










